<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAMS - CIRCLES: a creative practice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #fefefe;
        }

        #ring-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        circle {
            transition: stroke-width 0.3s ease, stroke 0.3s ease;
        }

        circle.clicked {
            stroke-width: inherit;
        }

        #pattern-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #pattern-select {
            padding: 8px 16px;
            font-size: 14px;
            border: 2px solid #333;
            border-radius: 4px;
            background: #fefefe;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s ease;
        }

        #pattern-select:hover {
            border-color: #DA3B32;
        }

        #pattern-select:focus {
            border-color: #153D65;
        }

        .keyboard-hint {
            display: block;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <svg id="ring-canvas"></svg>

    <div id="pattern-controls">
        <select id="pattern-select">
            <option value="diagonal">Diagonal Scatter</option>
            <option value="dnaHelix">Double Helix</option>
            <option value="honeycomb">Honeycomb</option>
            <option value="socialGraph">Social Graph</option>
            <option value="waveFlow">Wave Flow</option>
        </select>
    </div>

    <script>
        // Mobile-responsive configuration
        const BREAKPOINTS = {
            mobile: 480,
            tablet: 768,
            desktop: 1024
        };

        function getDeviceType() {
            const width = window.innerWidth;
            if (width < BREAKPOINTS.mobile) return 'mobile-small';
            if (width < BREAKPOINTS.tablet) return 'mobile';
            if (width < BREAKPOINTS.desktop) return 'tablet';
            return 'desktop';
        }

        // Device-specific style multipliers
        const DEVICE_STYLES = {
            'mobile-small': {
                ringSize: 28,
                strokeWidth: 6,
                amplitudeMin: 4,
                amplitudeMax: 12,
                repelRadius: 60,
                minDistance: 65,
                preferredDistance: 75,
                patterns: {
                    diagonal: {
                        corridorWidthMultiplier: 0.35,
                        paddingX: 0.08,
                        paddingY: 0.10,
                        pullStrength: 0.55,
                        pullChance: 0.35
                    },
                    dnaHelix: {
                        amplitude: 40,
                        frequency: 2.5,
                        edgePadding: 0.08,
                        verticalMode: true
                    },
                    honeycomb: {
                        cellSize: 70,
                        forcedColumns: 4,
                        jitter: 5
                    },
                    socialGraph: {
                        verticalLayout: true,
                        clusterPositions: [
                            { x: 0.5, y: 0.12 },
                            { x: 0.5, y: 0.37 },
                            { x: 0.5, y: 0.63 },
                            { x: 0.5, y: 0.88 }
                        ],
                        ringSpacing: 55
                    },
                    waveFlow: {
                        verticalMode: true,
                        waveCount: 3,
                        baseAmplitude: 0.12
                    }
                }
            },
            'mobile': {
                ringSize: 35,
                strokeWidth: 8,
                amplitudeMin: 5,
                amplitudeMax: 15,
                repelRadius: 80,
                minDistance: 80,
                preferredDistance: 90,
                patterns: {
                    diagonal: {
                        corridorWidthMultiplier: 0.4,
                        paddingX: 0.10,
                        paddingY: 0.10,
                        pullStrength: 0.5,
                        pullChance: 0.30
                    },
                    dnaHelix: {
                        amplitude: 55,
                        frequency: 2.2,
                        edgePadding: 0.10,
                        verticalMode: true
                    },
                    honeycomb: {
                        cellSize: 85,
                        forcedColumns: 5,
                        jitter: 6
                    },
                    socialGraph: {
                        verticalLayout: true,
                        clusterPositions: [
                            { x: 0.5, y: 0.12 },
                            { x: 0.5, y: 0.37 },
                            { x: 0.5, y: 0.63 },
                            { x: 0.5, y: 0.88 }
                        ],
                        ringSpacing: 65
                    },
                    waveFlow: {
                        verticalMode: true,
                        waveCount: 3,
                        baseAmplitude: 0.10
                    }
                }
            },
            'tablet': {
                ringSize: 42,
                strokeWidth: 11,
                amplitudeMin: 6,
                amplitudeMax: 20,
                repelRadius: 100,
                minDistance: 100,
                preferredDistance: 110,
                patterns: {}
            },
            'desktop': {
                ringSize: 50,
                strokeWidth: 14,
                amplitudeMin: 8,
                amplitudeMax: 25,
                repelRadius: 120,
                minDistance: 120,
                preferredDistance: 130,
                patterns: {}
            }
        };

        function getResponsiveValues() {
            const deviceType = getDeviceType();
            return DEVICE_STYLES[deviceType];
        }

        // Helper to get pattern config merged with mobile overrides
        function getPatternConfig(patternName) {
            const deviceType = getDeviceType();
            const devicePatterns = DEVICE_STYLES[deviceType].patterns || {};
            return devicePatterns[patternName] || {};
        }

        // Check if we're in portrait mobile mode
        function isPortraitMobile() {
            const deviceType = getDeviceType();
            return deviceType.includes('mobile') && window.innerHeight > window.innerWidth;
        }

        const responsive = getResponsiveValues();

        const CONFIG = {
            ringCount: 38,
            colors: ['#000000', '#DA3B32', '#153D65', '#0F5C2F'],
            ringSize: responsive.ringSize,
            strokeWidth: responsive.strokeWidth,
            animation: {
                amplitudeMin: responsive.amplitudeMin,
                amplitudeMax: responsive.amplitudeMax,
                speedMin: 0.0003,
                speedMax: 0.0015
            },
            mouse: {
                repelRadius: responsive.repelRadius,
                repelStrength: 0.08,
                returnSpeed: 0.03
            },
            spacing: {
                minDistance: responsive.minDistance,
                preferredDistance: responsive.preferredDistance
            },
            patterns: {
                diagonal: {
                    relaxationIterations: 50
                },
                dnaHelix: {
                    amplitude: 90,
                    frequency: 1.8,
                    edgePadding: 0.12,
                    strandOffset: Math.PI,
                    jitter: 7,
                    diagonalDirection: 1
                },
                honeycomb: {
                    cellSize: 140,
                    jitter: 8,
                    fillRatio: 0.8
                },
                socialGraph: {
                    clusterCount: 4,
                    clusterRadius: 200,
                    interClusterSpacing: 0.2,
                    jitter: 8,
                    ringSpacing: 95
                },
                waveFlow: {
                    waveCount: 4,
                    baseAmplitude: 0.08,
                    amplitudeVariation: 0.04,
                    primaryFrequency: 0.9,
                    secondaryFrequency: 2.1,
                    secondaryStrength: 0.3,
                    phaseProgression: 0.15,
                    convergeFactor: 0.12,
                    asymmetry: 0.25,
                    amplitudeModulation: 0.3,
                    jitter: 5
                }
            }
        };

        let currentPattern = 'diagonal';

        const rings = [];
        const svg = document.getElementById('ring-canvas');
        let mouseX = -1000;
        let mouseY = -1000;

        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomChoice(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function applyCollisionRelaxation(positions, iterations) {
            const minDist = CONFIG.spacing.preferredDistance;
            const width = window.innerWidth;
            const height = window.innerHeight;
            const padding = 80;

            for (let iter = 0; iter < iterations; iter++) {
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        const dx = positions[j].x - positions[i].x;
                        const dy = positions[j].y - positions[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < minDist && dist > 0) {
                            const overlap = (minDist - dist) / 2;
                            const nx = dx / dist;
                            const ny = dy / dist;

                            positions[i].x -= nx * overlap * 0.5;
                            positions[i].y -= ny * overlap * 0.5;
                            positions[j].x += nx * overlap * 0.5;
                            positions[j].y += ny * overlap * 0.5;
                        }
                    }
                }

                positions.forEach(p => {
                    p.x = Math.max(padding, Math.min(width - padding, p.x));
                    p.y = Math.max(padding, Math.min(height - padding, p.y));
                });
            }

            return positions;
        }

        let cachedDiagonalPositions = null;

        function generateDiagonalPositions(total) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const mobilePortrait = isPortraitMobile();
            const mobileConfig = getPatternConfig('diagonal');

            // Use mobile-specific padding or defaults
            const paddingX = width * (mobileConfig.paddingX || 0.12);
            const paddingY = height * (mobileConfig.paddingY || 0.12);

            // Narrower corridor on mobile portrait
            const corridorMultiplier = mobileConfig.corridorWidthMultiplier || 0.5;
            const corridorWidth = mobilePortrait
                ? width * corridorMultiplier
                : Math.min(width, height) * corridorMultiplier;

            const pullStrength = mobileConfig.pullStrength || 0.4;
            const pullChance = mobileConfig.pullChance || 0.2;

            const positions = [];

            for (let i = 0; i < total; i++) {
                const progress = i / total;
                const baseX = progress * (width - paddingX * 2) + paddingX;
                const baseY = (1 - progress) * (height - paddingY * 2) + paddingY;

                let offsetX, offsetY;
                if (mobilePortrait) {
                    // On mobile portrait: reduce horizontal spread, increase vertical
                    offsetX = (Math.random() - 0.5) * corridorWidth * 0.6;
                    offsetY = (Math.random() - 0.5) * corridorWidth * 1.2;
                } else {
                    offsetX = (Math.random() - 0.5) * corridorWidth;
                    offsetY = (Math.random() - 0.5) * corridorWidth;
                }

                let x = Math.max(paddingX, Math.min(width - paddingX, baseX + offsetX));
                let y = Math.max(paddingY, Math.min(height - paddingY, baseY + offsetY));

                // More rings pulled to center on mobile
                if (Math.random() < pullChance) {
                    x = x + (centerX - x) * pullStrength;
                    y = y + (centerY - y) * pullStrength;
                }

                positions.push({ x, y });
            }

            const iterations = CONFIG.patterns.diagonal.relaxationIterations;
            return applyCollisionRelaxation(positions, iterations);
        }

        function getDiagonalPosition(index, total) {
            if (!cachedDiagonalPositions || cachedDiagonalPositions.length !== total) {
                cachedDiagonalPositions = generateDiagonalPositions(total);
            }
            return cachedDiagonalPositions[index];
        }

        function getDNAHelixPosition(index, total) {
            const baseConfig = CONFIG.patterns.dnaHelix;
            const mobileConfig = getPatternConfig('dnaHelix');
            const width = window.innerWidth;
            const height = window.innerHeight;
            const idealSpacing = CONFIG.spacing.preferredDistance;
            const mobilePortrait = isPortraitMobile();

            const strand = index % 2;
            const strandIndex = Math.floor(index / 2);
            const strandTotal = Math.ceil(total / 2);

            // Use mobile amplitude/frequency if available
            const helixAmplitude = mobileConfig.amplitude || baseConfig.amplitude;
            const frequency = mobileConfig.frequency || baseConfig.frequency;
            const basePaddingPercent = mobileConfig.edgePadding || baseConfig.edgePadding;

            // Vertical mode for mobile portrait: helix runs top-to-bottom
            if (mobilePortrait && mobileConfig.verticalMode) {
                const paddingX = Math.max(width * 0.15, helixAmplitude + 40);
                const paddingY = height * basePaddingPercent;

                const spineLength = height - paddingY * 2;
                const maxSpacing = strandTotal > 1 ? spineLength / (strandTotal - 1) : 0;
                const actualSpacing = Math.min(idealSpacing, maxSpacing);
                const usedLength = (strandTotal - 1) * actualSpacing;
                const startOffset = (spineLength - usedLength) / 2;

                const progress = strandTotal > 1 ? strandIndex / (strandTotal - 1) : 0.5;
                const distanceAlongSpine = startOffset + progress * usedLength;

                const spineX = width / 2;
                const spineY = paddingY + distanceAlongSpine;

                // Oscillate horizontally
                const phase = strand * baseConfig.strandOffset;
                const oscillationValue = Math.sin(progress * Math.PI * 2 * frequency + phase);

                const helixX = spineX + oscillationValue * helixAmplitude;
                const helixY = spineY;

                const jitterX = (Math.random() - 0.5) * baseConfig.jitter * 2;
                const jitterY = (Math.random() - 0.5) * baseConfig.jitter * 2;

                return { x: helixX + jitterX, y: helixY + jitterY };
            }

            // Original diagonal mode for desktop/landscape
            const paddingX = Math.max(width * basePaddingPercent, helixAmplitude + 70);
            const paddingY = Math.max(height * basePaddingPercent, helixAmplitude + 70);

            const dir = baseConfig.diagonalDirection || 1;
            const startX = dir > 0 ? paddingX : width - paddingX;
            const startY = paddingY;
            const endX = dir > 0 ? width - paddingX : paddingX;
            const endY = height - paddingY;

            const diagonalDx = endX - startX;
            const diagonalDy = endY - startY;
            const diagonalLength = Math.sqrt(diagonalDx * diagonalDx + diagonalDy * diagonalDy);

            const maxSpacing = strandTotal > 1 ? diagonalLength / (strandTotal - 1) : 0;
            const actualSpacing = Math.min(idealSpacing, maxSpacing);
            const usedLength = (strandTotal - 1) * actualSpacing;
            const startOffset = (diagonalLength - usedLength) / 2;

            const progress = strandTotal > 1 ? strandIndex / (strandTotal - 1) : 0.5;

            const distanceAlongDiagonal = startOffset + progress * usedLength;
            const diagUnitX = diagonalDx / diagonalLength;
            const diagUnitY = diagonalDy / diagonalLength;

            const spineX = startX + distanceAlongDiagonal * diagUnitX;
            const spineY = startY + distanceAlongDiagonal * diagUnitY;

            const perpUnitX = -diagUnitY;
            const perpUnitY = diagUnitX;

            const phase = strand * baseConfig.strandOffset;
            const oscillationValue = Math.sin(progress * Math.PI * 2 * frequency + phase);

            const helixX = spineX + oscillationValue * helixAmplitude * perpUnitX;
            const helixY = spineY + oscillationValue * helixAmplitude * perpUnitY;

            const jitterX = (Math.random() - 0.5) * baseConfig.jitter * 2;
            const jitterY = (Math.random() - 0.5) * baseConfig.jitter * 2;

            return { x: helixX + jitterX, y: helixY + jitterY };
        }

        function getHoneycombPosition(index, total) {
            const baseConfig = CONFIG.patterns.honeycomb;
            const mobileConfig = getPatternConfig('honeycomb');
            const width = window.innerWidth;
            const height = window.innerHeight;
            const mobilePortrait = isPortraitMobile();

            // Use mobile cell size if available
            let cellSize = mobileConfig.cellSize || baseConfig.cellSize;
            const jitter = mobileConfig.jitter || baseConfig.jitter;

            let cols, rows;

            if (mobilePortrait && mobileConfig.forcedColumns) {
                // Force specific column count on mobile portrait
                cols = mobileConfig.forcedColumns;
                rows = Math.ceil(total / cols);

                // Ensure cells fit within screen width
                const maxCellWidth = (width - 40) / cols;
                cellSize = Math.min(cellSize, maxCellWidth);
            } else {
                cols = Math.ceil(Math.sqrt(total * (width / height)));
                rows = Math.ceil(total / cols);
            }

            const hexWidth = cellSize;
            const hexHeight = cellSize * Math.sqrt(3) / 2;

            const row = Math.floor(index / cols);
            const col = index % cols;

            const offsetX = (row % 2) * (hexWidth / 2);

            const gridWidth = cols * hexWidth;
            const gridHeight = rows * hexHeight;

            // Center the grid, ensure it fits on screen
            let startX = (width - gridWidth) / 2 + hexWidth / 2;
            let startY = (height - gridHeight) / 2 + hexHeight / 2;

            // On mobile, ensure positive start positions
            if (mobilePortrait) {
                startX = Math.max(hexWidth / 2, startX);
                startY = Math.max(hexHeight / 2, startY);
            }

            const baseX = startX + col * hexWidth + offsetX;
            const baseY = startY + row * hexHeight;

            const jitterX = (Math.random() - 0.5) * jitter * 2;
            const jitterY = (Math.random() - 0.5) * jitter * 2;

            return { x: baseX + jitterX, y: baseY + jitterY };
        }

        let cachedClusterCenters = null;

        function calculateClusterCenters(count, width, height) {
            const mobileConfig = getPatternConfig('socialGraph');
            const mobilePortrait = isPortraitMobile();
            const padding = Math.min(width, height) * 0.15;
            const centers = [];

            // Use mobile-specific vertical layout
            if (mobilePortrait && mobileConfig.verticalLayout && mobileConfig.clusterPositions) {
                mobileConfig.clusterPositions.forEach(p => {
                    centers.push({
                        x: p.x * width + (Math.random() - 0.5) * padding * 0.2,
                        y: p.y * height + (Math.random() - 0.5) * padding * 0.2
                    });
                });
                return centers;
            }

            // Original desktop layout
            if (count === 4) {
                const positions = [
                    { x: 0.34, y: 0.22 },
                    { x: 0.66, y: 0.18 },
                    { x: 0.32, y: 0.78 },
                    { x: 0.68, y: 0.82 }
                ];
                positions.forEach(p => {
                    centers.push({
                        x: p.x * width + (Math.random() - 0.5) * padding * 0.4,
                        y: p.y * height + (Math.random() - 0.5) * padding * 0.4
                    });
                });
            } else {
                const cols = Math.ceil(Math.sqrt(count));
                const rows = Math.ceil(count / cols);
                const cellW = (width - 2 * padding) / cols;
                const cellH = (height - 2 * padding) / rows;

                for (let i = 0; i < count; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    centers.push({
                        x: padding + cellW * (col + 0.5) + (Math.random() - 0.5) * cellW * 0.3,
                        y: padding + cellH * (row + 0.5) + (Math.random() - 0.5) * cellH * 0.3
                    });
                }
            }
            return centers;
        }

        function getSocialGraphPosition(index, total) {
            const baseConfig = CONFIG.patterns.socialGraph;
            const mobileConfig = getPatternConfig('socialGraph');
            const width = window.innerWidth;
            const height = window.innerHeight;
            const mobilePortrait = isPortraitMobile();
            const clusterCount = baseConfig.clusterCount;

            // Use mobile spacing if available
            const minSpacing = mobileConfig.ringSpacing || baseConfig.ringSpacing || CONFIG.spacing.preferredDistance;

            if (!cachedClusterCenters) {
                cachedClusterCenters = calculateClusterCenters(clusterCount, width, height);
            }

            const ringsPerCluster = Math.ceil(total / clusterCount);
            const clusterIndex = Math.min(Math.floor(index / ringsPerCluster), clusterCount - 1);
            const indexInCluster = index % ringsPerCluster;

            const center = cachedClusterCenters[clusterIndex];

            if (indexInCluster === 0) {
                const jitterX = (Math.random() - 0.5) * baseConfig.jitter * 2;
                const jitterY = (Math.random() - 0.5) * baseConfig.jitter * 2;
                return { x: center.x + jitterX, y: center.y + jitterY };
            }

            let layer = 1;
            let ringsInPreviousLayers = 1;
            while (ringsInPreviousLayers + Math.floor(2 * Math.PI * layer * minSpacing / minSpacing) < indexInCluster + 1) {
                ringsInPreviousLayers += Math.max(1, Math.floor(2 * Math.PI * layer));
                layer++;
            }

            const radius = layer * minSpacing;
            const ringsInThisLayer = Math.max(1, Math.floor(2 * Math.PI * layer));
            const positionInLayer = indexInCluster - ringsInPreviousLayers + ringsInThisLayer;
            const angleStep = (2 * Math.PI) / ringsInThisLayer;
            const angle = positionInLayer * angleStep + layer * 0.618;

            let baseX = center.x + Math.cos(angle) * radius;
            let baseY = center.y + Math.sin(angle) * radius;

            // Clamp to screen bounds on mobile
            if (mobilePortrait) {
                const padding = 30;
                baseX = Math.max(padding, Math.min(width - padding, baseX));
                baseY = Math.max(padding, Math.min(height - padding, baseY));
            }

            const jitterX = (Math.random() - 0.5) * baseConfig.jitter * 2;
            const jitterY = (Math.random() - 0.5) * baseConfig.jitter * 2;

            return { x: baseX + jitterX, y: baseY + jitterY };
        }

        function getWaveFlowPosition(index, total) {
            const baseConfig = CONFIG.patterns.waveFlow;
            const mobileConfig = getPatternConfig('waveFlow');
            const width = window.innerWidth;
            const height = window.innerHeight;
            const mobilePortrait = isPortraitMobile();
            const minSpacing = CONFIG.spacing.preferredDistance;

            // Use mobile wave count and amplitude if available
            const waveCount = mobileConfig.waveCount || baseConfig.waveCount;
            const baseAmplitude = mobileConfig.baseAmplitude || baseConfig.baseAmplitude;

            const ringsPerWave = Math.ceil(total / waveCount);
            const waveIndex = Math.floor(index / ringsPerWave);
            const indexInWave = index % ringsPerWave;
            const waveTotal = Math.min(ringsPerWave, total - waveIndex * ringsPerWave);

            // Vertical mode for mobile portrait: waves run top-to-bottom
            if (mobilePortrait && mobileConfig.verticalMode) {
                // Calculate Y position with spacing along wave
                const requiredHeight = (waveTotal - 1) * minSpacing;
                const paddingY = Math.max(height * 0.08, (height - requiredHeight) / 2);
                const usableHeight = Math.max(requiredHeight, height - 2 * paddingY);
                const actualSpacing = waveTotal > 1 ? usableHeight / (waveTotal - 1) : 0;
                let y = paddingY + indexInWave * actualSpacing;

                const progress = waveTotal > 1 ? indexInWave / (waveTotal - 1) : 0.5;
                const waveNormalized = (waveIndex - (waveCount - 1) / 2) / ((waveCount - 1) / 2 || 1);

                // Amplitude relative to width for horizontal oscillation
                const waveAmplitude = width * (baseAmplitude + baseConfig.amplitudeVariation * (1 - Math.abs(waveNormalized)));
                const lengthModulation = 1 - Math.abs(progress - 0.5) * 2 * baseConfig.amplitudeModulation;
                const modulatedAmplitude = waveAmplitude * Math.max(0.5, lengthModulation);

                // Base X position - waves spread horizontally
                const waveSpacing = width / (waveCount + 1);
                const baseX = waveSpacing * (waveIndex + 1);
                const centerX = width / 2;
                const convergeOffset = (centerX - baseX) * baseConfig.convergeFactor * (1 - Math.abs(progress - 0.5) * 2);

                // Phase calculations
                const basePhase = waveIndex * (Math.PI * 0.7);
                const progressivePhase = progress * Math.PI * baseConfig.phaseProgression;
                const totalPhase = basePhase + progressivePhase;

                // Primary wave (oscillates horizontally)
                const primaryWave = Math.sin(progress * Math.PI * 2 * baseConfig.primaryFrequency + totalPhase);
                const secondaryPhase = totalPhase * 1.5 + Math.PI * 0.3;
                const secondaryWave = Math.sin(progress * Math.PI * 2 * baseConfig.secondaryFrequency + secondaryPhase);

                let combinedWave = primaryWave + secondaryWave * baseConfig.secondaryStrength;
                combinedWave = combinedWave / (1 + baseConfig.secondaryStrength);

                if (baseConfig.asymmetry > 0) {
                    const asymmetryFactor = combinedWave > 0
                        ? Math.pow(Math.abs(combinedWave), 1 - baseConfig.asymmetry * 0.5)
                        : -Math.pow(Math.abs(combinedWave), 1 + baseConfig.asymmetry * 0.3);
                    combinedWave = asymmetryFactor;
                }

                const waveOffset = combinedWave * modulatedAmplitude;
                const x = baseX + convergeOffset + waveOffset;
                const yWobble = Math.sin(progress * Math.PI * 3 + waveIndex) * height * 0.008;

                const jitterX = (Math.random() - 0.5) * baseConfig.jitter * 2;
                const jitterY = (Math.random() - 0.5) * baseConfig.jitter * 2;

                return { x: x + jitterX, y: y + yWobble + jitterY };
            }

            // Original horizontal wave mode for desktop/landscape
            const requiredWidth = (waveTotal - 1) * minSpacing;
            const paddingX = Math.max(width * 0.08, (width - requiredWidth) / 2);
            const usableWidth = Math.max(requiredWidth, width - 2 * paddingX);
            const actualSpacing = waveTotal > 1 ? usableWidth / (waveTotal - 1) : 0;
            let x = paddingX + indexInWave * actualSpacing;

            const progress = waveTotal > 1 ? indexInWave / (waveTotal - 1) : 0.5;
            const waveNormalized = (waveIndex - (waveCount - 1) / 2) / ((waveCount - 1) / 2 || 1);

            const waveAmplitude = height * (baseAmplitude + baseConfig.amplitudeVariation * (1 - Math.abs(waveNormalized)));
            const lengthModulation = 1 - Math.abs(progress - 0.5) * 2 * baseConfig.amplitudeModulation;
            const modulatedAmplitude = waveAmplitude * Math.max(0.5, lengthModulation);

            const waveSpacing = height / (waveCount + 1);
            const baseY = waveSpacing * (waveIndex + 1);
            const centerY = height / 2;
            const convergeOffset = (centerY - baseY) * baseConfig.convergeFactor * (1 - Math.abs(progress - 0.5) * 2);

            const basePhase = waveIndex * (Math.PI * 0.7);
            const progressivePhase = progress * Math.PI * baseConfig.phaseProgression;
            const totalPhase = basePhase + progressivePhase;

            const primaryWave = Math.sin(progress * Math.PI * 2 * baseConfig.primaryFrequency + totalPhase);
            const secondaryPhase = totalPhase * 1.5 + Math.PI * 0.3;
            const secondaryWave = Math.sin(progress * Math.PI * 2 * baseConfig.secondaryFrequency + secondaryPhase);

            let combinedWave = primaryWave + secondaryWave * baseConfig.secondaryStrength;
            combinedWave = combinedWave / (1 + baseConfig.secondaryStrength);

            if (baseConfig.asymmetry > 0) {
                const asymmetryFactor = combinedWave > 0
                    ? Math.pow(Math.abs(combinedWave), 1 - baseConfig.asymmetry * 0.5)
                    : -Math.pow(Math.abs(combinedWave), 1 + baseConfig.asymmetry * 0.3);
                combinedWave = asymmetryFactor;
            }

            const waveOffset = combinedWave * modulatedAmplitude;
            const y = baseY + convergeOffset + waveOffset;
            const xWobble = Math.sin(progress * Math.PI * 3 + waveIndex) * width * 0.008;

            const jitterX = (Math.random() - 0.5) * baseConfig.jitter * 2;
            const jitterY = (Math.random() - 0.5) * baseConfig.jitter * 2;

            return { x: x + xWobble + jitterX, y: y + jitterY };
        }

        const PATTERN_GENERATORS = {
            diagonal: getDiagonalPosition,
            dnaHelix: getDNAHelixPosition,
            honeycomb: getHoneycombPosition,
            socialGraph: getSocialGraphPosition,
            waveFlow: getWaveFlowPosition
        };

        function createRing(id, index, total) {
            const generator = PATTERN_GENERATORS[currentPattern];
            const pos = generator(index, total);

            return {
                id: id,
                element: null,
                baseX: pos.x,
                baseY: pos.y,
                currentOffsetX: 0,
                currentOffsetY: 0,
                repelOffsetX: 0,
                repelOffsetY: 0,
                radius: CONFIG.ringSize,
                color: randomChoice(CONFIG.colors),
                originalColor: null,
                strokeWidth: CONFIG.strokeWidth,
                amplitude: randomRange(CONFIG.animation.amplitudeMin, CONFIG.animation.amplitudeMax),
                speedX: randomRange(CONFIG.animation.speedMin, CONFIG.animation.speedMax),
                speedY: randomRange(CONFIG.animation.speedMin, CONFIG.animation.speedMax),
                phaseX: Math.random() * Math.PI * 2,
                phaseY: Math.random() * Math.PI * 2,
                isClicked: false,
                clickScale: 1,
                flipProgress: 0,
                isFlipping: false,
                flipAngle: 0
            };
        }

        function createSVGCircle(ring) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', ring.baseX);
            circle.setAttribute('cy', ring.baseY);
            circle.setAttribute('r', ring.radius);
            circle.setAttribute('stroke', ring.color);
            circle.setAttribute('stroke-width', ring.strokeWidth);
            circle.setAttribute('fill', 'none');
            circle.dataset.ringId = ring.id;
            return circle;
        }

        function regenerateRings(patternName) {
            currentPattern = patternName;
            cachedClusterCenters = null;
            cachedDiagonalPositions = null;
            const generator = PATTERN_GENERATORS[patternName];

            rings.forEach((ring, index) => {
                const pos = generator(index, CONFIG.ringCount);
                ring.baseX = pos.x;
                ring.baseY = pos.y;
                ring.element.setAttribute('cx', pos.x);
                ring.element.setAttribute('cy', pos.y);
                ring.repelOffsetX = 0;
                ring.repelOffsetY = 0;
            });
        }

        let isTransitioning = false;

        function transitionToPattern(patternName, duration = 800) {
            if (isTransitioning || patternName === currentPattern) return;
            isTransitioning = true;
            cachedClusterCenters = null;
            cachedDiagonalPositions = null;

            const generator = PATTERN_GENERATORS[patternName];

            const transitions = rings.map((ring, index) => {
                const target = generator(index, CONFIG.ringCount);
                return {
                    ring: ring,
                    startX: ring.baseX,
                    startY: ring.baseY,
                    targetX: target.x,
                    targetY: target.y
                };
            });

            const startTime = performance.now();

            function animateTransition(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                transitions.forEach(t => {
                    t.ring.baseX = t.startX + (t.targetX - t.startX) * eased;
                    t.ring.baseY = t.startY + (t.targetY - t.startY) * eased;
                    t.ring.element.setAttribute('cx', t.ring.baseX);
                    t.ring.element.setAttribute('cy', t.ring.baseY);
                });

                if (progress < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    currentPattern = patternName;
                    isTransitioning = false;
                }
            }

            requestAnimationFrame(animateTransition);
        }

        function initPatternControls() {
            const select = document.getElementById('pattern-select');

            select.addEventListener('change', (e) => {
                transitionToPattern(e.target.value);
            });

            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'SELECT') return;

                const patternKeys = {
                    '1': 'diagonal',
                    '2': 'dnaHelix',
                    '3': 'honeycomb',
                    '4': 'socialGraph',
                    '5': 'waveFlow'
                };

                if (patternKeys[e.key]) {
                    const pattern = patternKeys[e.key];
                    select.value = pattern;
                    transitionToPattern(pattern);
                }
            });
        }

        // Update CONFIG and ring styles when viewport changes
        function updateResponsiveConfig() {
            const newResponsive = getResponsiveValues();

            // Update CONFIG values
            CONFIG.ringSize = newResponsive.ringSize;
            CONFIG.strokeWidth = newResponsive.strokeWidth;
            CONFIG.animation.amplitudeMin = newResponsive.amplitudeMin;
            CONFIG.animation.amplitudeMax = newResponsive.amplitudeMax;
            CONFIG.mouse.repelRadius = newResponsive.repelRadius;
            CONFIG.spacing.minDistance = newResponsive.minDistance;
            CONFIG.spacing.preferredDistance = newResponsive.preferredDistance;

            // Update existing rings with new sizes
            rings.forEach(ring => {
                ring.radius = CONFIG.ringSize;
                ring.strokeWidth = CONFIG.strokeWidth;
                ring.amplitude = randomRange(CONFIG.animation.amplitudeMin, CONFIG.animation.amplitudeMax);
                ring.element.setAttribute('r', ring.radius);
                ring.element.setAttribute('stroke-width', ring.strokeWidth);
            });
        }

        let resizeTimeout;
        let lastDeviceType = getDeviceType();

        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const newDeviceType = getDeviceType();

                // Only update ring styles if device type changed
                if (newDeviceType !== lastDeviceType) {
                    lastDeviceType = newDeviceType;
                    updateResponsiveConfig();
                }

                regenerateRings(currentPattern);
            }, 250);
        });

        function init() {
            const patternNames = Object.keys(PATTERN_GENERATORS);
            currentPattern = patternNames[Math.floor(Math.random() * patternNames.length)];

            document.getElementById('pattern-select').value = currentPattern;

            for (let i = 0; i < CONFIG.ringCount; i++) {
                rings.push(createRing(i, i, CONFIG.ringCount));
            }

            rings.sort((a, b) => b.radius - a.radius);

            rings.forEach(ring => {
                ring.originalColor = ring.color;
                ring.element = createSVGCircle(ring);
                svg.appendChild(ring.element);
            });

            svg.addEventListener('mousemove', handleMouseMove);
            svg.addEventListener('mouseleave', handleMouseLeave);
            svg.addEventListener('click', handleClick);

            initPatternControls();
            animate(0);
        }

        function handleMouseMove(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function handleMouseLeave() {
            mouseX = -1000;
            mouseY = -1000;
        }

        function handleClick(e) {
            const clickX = e.clientX;
            const clickY = e.clientY;

            for (let i = rings.length - 1; i >= 0; i--) {
                const ring = rings[i];
                const ringX = ring.baseX + ring.currentOffsetX + ring.repelOffsetX;
                const ringY = ring.baseY + ring.currentOffsetY + ring.repelOffsetY;
                const dx = clickX - ringX;
                const dy = clickY - ringY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= ring.radius + ring.strokeWidth) {
                    triggerClickEffect(ring);
                    break;
                }
            }
        }

        function triggerClickEffect(ring) {
            ring.isFlipping = true;
            ring.flipProgress = 0;
            // Random diagonal: either ~45° or ~-45° (with some variation)
            ring.flipAngle = (Math.random() < 0.5 ? 1 : -1) * (35 + Math.random() * 20);
        }

        function animate(timestamp) {
            rings.forEach(ring => {
                const floatX = Math.sin(timestamp * ring.speedX + ring.phaseX) * ring.amplitude;
                const floatY = Math.cos(timestamp * ring.speedY + ring.phaseY) * ring.amplitude;

                ring.currentOffsetX = floatX;
                ring.currentOffsetY = floatY;

                const ringX = ring.baseX + floatX + ring.repelOffsetX;
                const ringY = ring.baseY + floatY + ring.repelOffsetY;
                const dx = mouseX - ringX;
                const dy = mouseY - ringY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < CONFIG.mouse.repelRadius && distance > 0) {
                    const force = (CONFIG.mouse.repelRadius - distance) / CONFIG.mouse.repelRadius;
                    const angle = Math.atan2(dy, dx);
                    ring.repelOffsetX += Math.cos(angle) * force * CONFIG.mouse.repelStrength * ring.amplitude;
                    ring.repelOffsetY += Math.sin(angle) * force * CONFIG.mouse.repelStrength * ring.amplitude;
                }

                ring.repelOffsetX *= (1 - CONFIG.mouse.returnSpeed);
                ring.repelOffsetY *= (1 - CONFIG.mouse.returnSpeed);

                // Handle flip animation
                const totalOffsetX = floatX + ring.repelOffsetX;
                const totalOffsetY = floatY + ring.repelOffsetY;
                const cx = ring.baseX;
                const cy = ring.baseY;

                let transform = `translate(${totalOffsetX}, ${totalOffsetY})`;

                if (ring.isFlipping) {
                    ring.flipProgress += 0.08;
                    if (ring.flipProgress >= 1) {
                        ring.isFlipping = false;
                        ring.flipProgress = 0;
                    } else {
                        // Full flip along diagonal axis
                        const flipScale = Math.cos(ring.flipProgress * Math.PI * 2);
                        // Transform order: offset, then flip around base center
                        transform = `translate(${totalOffsetX + cx}, ${totalOffsetY + cy}) rotate(${ring.flipAngle}) scale(${flipScale}, 1) rotate(${-ring.flipAngle}) translate(${-cx}, ${-cy})`;
                    }
                }

                ring.element.setAttribute('transform', transform);
            });

            requestAnimationFrame(animate);
        }

        // Ring control API
        function getRing(id) {
            return rings.find(r => r.id === id);
        }

        function setRingColor(id, color) {
            const ring = getRing(id);
            if (ring) {
                ring.color = color;
                ring.originalColor = color;
                ring.element.setAttribute('stroke', color);
            }
        }

        function moveRing(id, x, y) {
            const ring = getRing(id);
            if (ring) {
                ring.baseX = x;
                ring.baseY = y;
                ring.element.setAttribute('cx', x);
                ring.element.setAttribute('cy', y);
            }
        }

        function pauseRing(id) {
            const ring = getRing(id);
            if (ring) {
                ring.amplitude = 0;
            }
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
